# What is Rush-FS?

Rush-FS is an **API-aligned, drop-in replacement** for the Node.js `fs` module. It is implemented in Rust and exposes the same API surface so you can swap the import and get **multi-fold performance** in heavy file operations without changing your code.

## Why Rush-FS?

- **Drop-in replacement** — Same API as Node.js `fs`; swap the import and go.
- **Faster where it matters** — Recursive `readdir`, `glob`, `rm`, and `cp` are 2–70× faster thanks to Rust's parallel walkers and zero-copy I/O.
- **Prebuilt binaries** — No build step for users; we ship native binaries per platform (Windows, macOS, Linux).

## How it works (in short)

Node.js `fs` uses a serial libuv thread pool and does a lot of work on the V8 main thread (string allocation, GC pressure). Rush-FS moves the heavy work into Rust: parallel directory traversal (e.g. jwalk, rayon), then a single batch handoff over N-API. That reduces V8 interaction and unlocks 2–70× speedups for recursive and batch operations.

For more detail and diagrams, see the [README — How it works](https://github.com/CoderSerio/rush-fs#how-it-works) on GitHub.

## Quick example

```ts
import { readdir, readFile, writeFile, rm } from '@rush-fs/core'

const files = await readdir('./src', { recursive: true, withFileTypes: true })
const content = await readFile('./package.json', { encoding: 'utf8' })
await writeFile('./out.txt', content)
await rm('./temp', { recursive: true, force: true })
```
